<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>golang中反射reflect示例</title>
      <link href="/2020/03/15/golang-zhong-fan-she-reflect-shi-li/"/>
      <url>/2020/03/15/golang-zhong-fan-she-reflect-shi-li/</url>
      
        <content type="html"><![CDATA[<h1 id="golang中的反射reflect示例"><a href="#golang中的反射reflect示例" class="headerlink" title="golang中的反射reflect示例"></a>golang中的反射reflect示例</h1><h2 id="编程语言中反射的概念"><a href="#编程语言中反射的概念" class="headerlink" title="编程语言中反射的概念"></a>编程语言中反射的概念</h2><p>在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。</p><p>每种语言的反射模型都不同，并且有些语言根本不支持反射。Golang语言实现了反射，反射机制就是在运行时动态的调用对象的方法和属性，官方自带的reflect包就是反射相关的，只要包含这个包就可以使用。</p><p>多插一句，Golang的gRPC也是通过反射实现的。</p><h2 id="interface和反射"><a href="#interface和反射" class="headerlink" title="interface和反射"></a>interface和反射</h2><p>在讲反射之前，先来看看Golang关于类型设计的一些原则</p><ul><li>变量包括（type, value）两部分<ul><li>理解这一点就知道为什么nil != nil了</li></ul></li><li>type 包括 static type和concrete type. 简单来说 static type是你在编码是看见的类型(如int、string)，concrete type是runtime系统看见的类型</li><li>类型断言能否成功，取决于变量的concrete type，而不是static type. 因此，一个 reader变量如果它的concrete type也实现了write方法的话，它也可以被类型断言为writer.</li></ul><p>接下来要讲的反射，就是建立在类型之上的，Golang的指定类型的变量的类型是静态的（也就是指定int、string这些的变量，它的type是static type），在创建变量的时候就已经确定，反射主要与Golang的interface类型相关（它的type是concrete type），只有interface类型才有反射一说。</p><p>在Golang的实现中，每个interface变量都有一个对应pair，pair中记录了实际变量的值和类型:</p><pre class="line-numbers language-go"><code class="language-go"><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>value是实际变量值，type是实际变量的类型。一个interface{}类型的变量包含了2个指针，一个指针指向值的类型【对应concrete type】，另外一个指针指向实际的值【对应value】。例如，创建类型为*os.File的变量，然后将其赋给一个接口变量r：</p><pre class="line-numbers language-go"><code class="language-go">tty<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span><span class="token string">"/dev/tty"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_RDWR<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">var</span> r io<span class="token punctuation">.</span>Readerr <span class="token operator">=</span> tty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>接口变量r的pair中将记录如下信息：(tty, *os.File)，这个pair在接口变量的连续赋值过程中是不变的，将接口变量r赋给另一个接口变量w:</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> w io<span class="token punctuation">.</span>Writerw <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>Writer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接口变量w的pair与r的pair相同，都是:(tty, *os.File)，即使w是空接口类型，pair也是不变的。</p><p>interface及其pair的存在，是Golang中实现反射的前提，理解了pair，就更容易理解反射。反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。</p><h2 id="golang的反射reflect"><a href="#golang的反射reflect" class="headerlink" title="golang的反射reflect"></a>golang的反射reflect</h2><h3 id="reflect的基本功能TypeOf和ValueOf"><a href="#reflect的基本功能TypeOf和ValueOf" class="headerlink" title="reflect的基本功能TypeOf和ValueOf"></a>reflect的基本功能TypeOf和ValueOf</h3><p>既然反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。那么在Golang的reflect反射包中有什么样的方式可以让我们直接获取到变量内部的信息呢？ 它提供了两种类型（或者说两个方法）让我们可以很容易的访问接口变量内容，分别是reflect.ValueOf() 和 reflect.TypeOf()，看看官方的解释</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// ValueOf returns a new Value initialized to the concrete value</span><span class="token comment" spellcheck="true">// stored in the interface i.  ValueOf(nil) returns the zero </span><span class="token keyword">func</span> <span class="token function">ValueOf</span><span class="token punctuation">(</span>i <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> Value <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>翻译一下：ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回<span class="token number">0</span><span class="token comment" spellcheck="true">// TypeOf returns the reflection Type that represents the dynamic type of i.</span><span class="token comment" spellcheck="true">// If i is a nil interface value, TypeOf returns nil.</span><span class="token keyword">func</span> <span class="token function">TypeOf</span><span class="token punctuation">(</span>i <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> Type <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>翻译一下：TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回<span class="token boolean">nil</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>reflect.TypeOf()是获取pair中的type，reflect.ValueOf()获取pair中的value，示例如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"reflect"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> num <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">1.2345</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"type: "</span><span class="token punctuation">,</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"value: "</span><span class="token punctuation">,</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>运行结果<span class="token punctuation">:</span><span class="token keyword">type</span><span class="token punctuation">:</span>  <span class="token builtin">float64</span>value<span class="token punctuation">:</span>  <span class="token number">1.2345</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol><li><p>reflect.TypeOf： 直接给到了我们想要的type类型，如float64、int、各种pointer、struct 等等真实的类型</p></li><li><p>reflect.ValueOf：直接给到了我们想要的具体的值，如1.2345这个具体数值，或者类似&amp;{1 “Allen.Wu” 25} 这样的结构体struct的值</p></li><li><p>也就是说明反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是reflect.Type和reflect.Value这两种</p></li></ol><h3 id="从relfect-Value中获取接口interface的信息"><a href="#从relfect-Value中获取接口interface的信息" class="headerlink" title="从relfect.Value中获取接口interface的信息"></a>从relfect.Value中获取接口interface的信息</h3><p>当执行reflect.ValueOf(interface)之后，就得到了一个类型为”relfect.Value”变量，可以通过它本身的Interface()方法获得接口变量的真实内容，然后可以通过类型判断进行转换，转换为原有真实类型。不过，我们可能是已知原有类型，也有可能是未知原有类型，因此，下面分两种情况进行说明。</p><h4 id="已知原有类型【进行“强制转换”】"><a href="#已知原有类型【进行“强制转换”】" class="headerlink" title="已知原有类型【进行“强制转换”】"></a>已知原有类型【进行“强制转换”】</h4><p>已知类型后转换为其对应的类型的做法如下，直接通过Interface方法然后强制转换，如下：</p><pre class="line-numbers language-go"><code class="language-go">realValue <span class="token operator">:=</span> value<span class="token punctuation">.</span><span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span>已知的类型<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"reflect"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> num <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">1.2345</span>    pointer <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>num<span class="token punctuation">)</span>    value <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 可以理解为“强制转换”，但是需要注意的时候，转换的时候，如果转换的类型不完全符合，则直接panic</span>    <span class="token comment" spellcheck="true">// Golang 对类型要求非常严格，类型一定要完全符合</span>    <span class="token comment" spellcheck="true">// 如下两个，一个是*float64，一个是float64，如果弄混，则会panic</span>    convertPointer <span class="token operator">:=</span> pointer<span class="token punctuation">.</span><span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">float64</span><span class="token punctuation">)</span>    convertValue <span class="token operator">:=</span> value<span class="token punctuation">.</span><span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">float64</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>convertPointer<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>convertValue<span class="token punctuation">)</span><span class="token punctuation">}</span>运行结果：<span class="token number">0xc42000e238</span><span class="token number">1.2345</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><ol><li>转换的时候，如果转换的类型不完全符合，则直接panic，类型要求非常严格！</li><li>转换的时候，要区分是指针还是指</li><li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li></ol><h4 id="未知原有类型【遍历探测其Filed】"><a href="#未知原有类型【遍历探测其Filed】" class="headerlink" title="未知原有类型【遍历探测其Filed】"></a>未知原有类型【遍历探测其Filed】</h4><p>很多情况下，我们可能并不知道其具体类型，那么这个时候，该如何做呢？需要我们进行遍历探测其Filed来得知，示例如下:</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"reflect"</span><span class="token punctuation">)</span><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Id   <span class="token builtin">int</span>    Name <span class="token builtin">string</span>    Age  <span class="token builtin">int</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>u User<span class="token punctuation">)</span> <span class="token function">ReflectCallFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Allen.Wu ReflectCallFunc"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    user <span class="token operator">:=</span> User<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Allen.Wu"</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">}</span>    <span class="token function">DoFiledAndMethod</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 通过接口来获取任意参数，然后一一揭晓</span><span class="token keyword">func</span> <span class="token function">DoFiledAndMethod</span><span class="token punctuation">(</span>input <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    getType <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"get Type is :"</span><span class="token punctuation">,</span> getType<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    getValue <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"get all Fields is:"</span><span class="token punctuation">,</span> getValue<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 获取方法字段</span>    <span class="token comment" spellcheck="true">// 1. 先获取interface的reflect.Type，然后通过NumField进行遍历</span>    <span class="token comment" spellcheck="true">// 2. 再通过reflect.Type的Field获取其Field</span>    <span class="token comment" spellcheck="true">// 3. 最后通过Field的Interface()得到对应的value</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> getType<span class="token punctuation">.</span><span class="token function">NumField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        field <span class="token operator">:=</span> getType<span class="token punctuation">.</span><span class="token function">Field</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        value <span class="token operator">:=</span> getValue<span class="token punctuation">.</span><span class="token function">Field</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s: %v = %v\n"</span><span class="token punctuation">,</span> field<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> field<span class="token punctuation">.</span>Type<span class="token punctuation">,</span> value<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 获取方法</span>    <span class="token comment" spellcheck="true">// 1. 先获取interface的reflect.Type，然后通过.NumMethod进行遍历</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> getType<span class="token punctuation">.</span><span class="token function">NumMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        m <span class="token operator">:=</span> getType<span class="token punctuation">.</span><span class="token function">Method</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s: %v\n"</span><span class="token punctuation">,</span> m<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> m<span class="token punctuation">.</span>Type<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>运行结果：get Type is <span class="token punctuation">:</span> Userget all Fields is<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token number">1</span> Allen<span class="token punctuation">.</span>Wu <span class="token number">25</span><span class="token punctuation">}</span>Id<span class="token punctuation">:</span> <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">1</span>Name<span class="token punctuation">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> Allen<span class="token punctuation">.</span>WuAge<span class="token punctuation">:</span> <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">25</span>ReflectCallFunc<span class="token punctuation">:</span> <span class="token keyword">func</span><span class="token punctuation">(</span>main<span class="token punctuation">.</span>User<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h5><p>通过运行结果可以得知获取未知类型的interface的具体变量及其类型的步骤为：</p><ol><li>先获取interface的reflect.Type，然后通过NumField进行遍历</li><li>再通过reflect.Type的Field获取其Field</li><li>最后通过Field的Interface()得到对应的value</li></ol><p>通过运行结果可以得知获取未知类型的interface的所属方法（函数）的步骤为：</p><ol><li>先获取interface的reflect.Type，然后通过NumMethod进行遍历</li><li>再分别通过reflect.Type的Method获取对应的真实的方法（函数）</li><li>最后对结果取其Name和Type得知具体的方法名</li><li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li><li>struct 或者 struct 的嵌套都是一样的判断处理方式</li></ol><h3 id="通过reflect-Value设置实际变量的值"><a href="#通过reflect-Value设置实际变量的值" class="headerlink" title="通过reflect.Value设置实际变量的值"></a>通过reflect.Value设置实际变量的值</h3><p>reflect.Value是通过reflect.ValueOf(X)获得的，只有当X是指针的时候，才可以通过reflec.Value修改实际变量X的值，即：要修改反射类型的对象就一定要保证其值是“addressable”的。</p><p>示例如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"reflect"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> num <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">1.2345</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"old value of pointer:"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 通过reflect.ValueOf获取num中的reflect.Value，注意，参数必须是指针才能修改其值</span>    pointer <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>num<span class="token punctuation">)</span>    newValue <span class="token operator">:=</span> pointer<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"type of pointer:"</span><span class="token punctuation">,</span> newValue<span class="token punctuation">.</span><span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"settability of pointer:"</span><span class="token punctuation">,</span> newValue<span class="token punctuation">.</span><span class="token function">CanSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 重新赋值</span>    newValue<span class="token punctuation">.</span><span class="token function">SetFloat</span><span class="token punctuation">(</span><span class="token number">77</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"new value of pointer:"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">////////////////////</span>    <span class="token comment" spellcheck="true">// 如果reflect.ValueOf的参数不是指针，会如何？</span>    pointer <span class="token operator">=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//newValue = pointer.Elem() // 如果非指针，这里直接panic，“panic: reflect: call of reflect.Value.Elem on float64 Value”</span><span class="token punctuation">}</span>运行结果：old value of pointer<span class="token punctuation">:</span> <span class="token number">1.2345</span><span class="token keyword">type</span> of pointer<span class="token punctuation">:</span> <span class="token builtin">float64</span>settability of pointer<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token builtin">new</span> value of pointer<span class="token punctuation">:</span> <span class="token number">77</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><ol><li>需要传入的参数是* float64这个指针，然后可以通过pointer.Elem()去获取所指向的Value，<strong>注意一定要是指针</strong>。</li><li>如果传入的参数不是指针，而是变量，那么<ul><li>通过Elem获取原始值对应的对象则直接panic</li><li>通过CanSet方法查询是否可以设置返回false</li></ul></li><li>newValue.CantSet()表示是否可以重新设置其值，如果输出的是true则可修改，否则不能修改，修改完之后再进行打印发现真的已经修改了。</li><li>reflect.Value.Elem() 表示获取原始值对应的反射对象，只有原始对象才能修改，当前反射对象是不能修改的</li><li>也就是说如果要修改反射类型对象，其值必须是“addressable”【对应的要传入的是指针，同时要通过Elem方法获取原始值对应的反射对象】</li><li>struct 或者 struct 的嵌套都是一样的判断处理方式</li></ol><h3 id="通过reflect-ValueOf来进行方法的调用"><a href="#通过reflect-ValueOf来进行方法的调用" class="headerlink" title="通过reflect.ValueOf来进行方法的调用"></a>通过reflect.ValueOf来进行方法的调用</h3><p>这算是一个高级用法了，前面我们只说到对类型、变量的几种反射的用法，包括如何获取其值、其类型、如果重新设置新值。但是在工程应用中，另外一个常用并且属于高级的用法，就是通过reflect来进行方法【函数】的调用。比如我们要做框架工程的时候，需要可以随意扩展方法，或者说用户可以自定义方法，那么我们通过什么手段来扩展让用户能够自定义呢？关键点在于用户的自定义方法是未可知的，因此我们可以通过reflect来搞定</p><p>示例如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"reflect"</span><span class="token punctuation">)</span><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Id   <span class="token builtin">int</span>    Name <span class="token builtin">string</span>    Age  <span class="token builtin">int</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>u User<span class="token punctuation">)</span> <span class="token function">ReflectCallFuncHasArgs</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> age <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ReflectCallFuncHasArgs name: "</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token string">", age:"</span><span class="token punctuation">,</span> age<span class="token punctuation">,</span> <span class="token string">"and origal User.Name:"</span><span class="token punctuation">,</span> u<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>u User<span class="token punctuation">)</span> <span class="token function">ReflectCallFuncNoArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ReflectCallFuncNoArgs"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 如何通过反射来进行方法的调用？</span><span class="token comment" spellcheck="true">// 本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调动mv.Call</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    user <span class="token operator">:=</span> User<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Allen.Wu"</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 1. 要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理</span>    getValue <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 一定要指定参数为正确的方法名</span>    <span class="token comment" spellcheck="true">// 2. 先看看带有参数的调用方法</span>    methodValue <span class="token operator">:=</span> getValue<span class="token punctuation">.</span><span class="token function">MethodByName</span><span class="token punctuation">(</span><span class="token string">"ReflectCallFuncHasArgs"</span><span class="token punctuation">)</span>    args <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>reflect<span class="token punctuation">.</span>Value<span class="token punctuation">{</span>reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span><span class="token string">"wudebao"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">}</span>    methodValue<span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 一定要指定参数为正确的方法名</span>    <span class="token comment" spellcheck="true">// 3. 再看看无参数的调用方法</span>    methodValue <span class="token operator">=</span> getValue<span class="token punctuation">.</span><span class="token function">MethodByName</span><span class="token punctuation">(</span><span class="token string">"ReflectCallFuncNoArgs"</span><span class="token punctuation">)</span>    args <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>reflect<span class="token punctuation">.</span>Value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    methodValue<span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">}</span>运行结果：ReflectCallFuncHasArgs name<span class="token punctuation">:</span>  wudebao <span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">30</span> and origal User<span class="token punctuation">.</span>Name<span class="token punctuation">:</span> Allen<span class="token punctuation">.</span>WuReflectCallFuncNoArgs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h4><ol><li>要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理</li><li>reflect.Value.MethodByName这.MethodByName，需要指定准确真实的方法名字，如果错误将直接panic，MethodByName返回一个函数值对应的reflect.Value方法的名字。</li><li>[]reflect.Value，这个是最终需要调用的方法的参数，可以没有或者一个或者多个，根据实际参数来定。</li><li>reflect.Value的 Call 这个方法，这个方法将最终调用真实的方法，参数务必保持一致，如果reflect.Value’Kind不是一个方法，那么将直接panic。</li><li>本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调用methodValue.Call</li></ol><h2 id="Golang的反射reflect性能"><a href="#Golang的反射reflect性能" class="headerlink" title="Golang的反射reflect性能"></a>Golang的反射reflect性能</h2><p>Golang的反射很慢，这个和它的API设计有关。在 java 里面，我们一般使用反射都是这样来弄的。</p><pre class="line-numbers language-java"><code class="language-java">Field field <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getField</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个取得的反射对象类型是 java.lang.reflect.Field。它是可以复用的。只要传入不同的obj，就可以取得这个obj上对应的 field。</p><p>但是Golang的反射不是这样设计的:</p><pre class="line-numbers language-go"><code class="language-go">type_ <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>field<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> type_<span class="token punctuation">.</span><span class="token function">FieldByName</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里取出来的 field 对象是 reflect.StructField 类型，但是它没有办法用来取得对应对象上的值。如果要取值，得用另外一套对object，而不是type的反射</p><pre class="line-numbers language-go"><code class="language-go">type_ <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>fieldValue <span class="token operator">:=</span> type_<span class="token punctuation">.</span><span class="token function">FieldByName</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里取出来的 fieldValue 类型是 reflect.Value，它是一个具体的值，而不是一个可复用的反射对象了，每次反射都需要malloc这个reflect.Value结构体，并且还涉及到GC。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Golang reflect慢主要有两个原因</p><ol><li>涉及到内存分配以及后续的GC；</li><li>reflect实现里面有大量的枚举，也就是for循环，比如类型之类的。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述详细说明了Golang的反射reflect的各种功能和用法，都附带有相应的示例，相信能够在工程应用中进行相应实践，总结一下就是：</p><ul><li><p>反射可以大大提高程序的灵活性，使得interface{}有更大的发挥余地</p><ul><li>反射必须结合interface才玩得转</li><li>变量的type要是concrete type的（也就是interface变量）才有反射一说</li></ul></li><li><p>反射可以将“接口类型变量”转换为“反射类型对象”</p><ul><li>反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息</li></ul></li><li><p>反射可以将“反射类型对象”转换为“接口类型变量</p><ul><li>reflect.value.Interface().(已知的类型)</li><li>遍历reflect.Type的Field获取其Field</li></ul></li><li><p>反射可以修改反射类型对象，但是其值必须是“addressable”</p><ul><li>想要利用反射修改对象状态，前提是 interface.data 是 settable,即 pointer-interface</li></ul></li><li><p>通过反射可以“动态”调用方法</p></li><li><p>因为Golang本身不支持模板，因此在以往需要使用模板的场景下往往就需要使用反射(reflect)来实现</p></li></ul><img src="/2020/03/15/golang-zhong-fan-she-reflect-shi-li/reflect.png" class="" title="这是我的截图"><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.golang.org/laws-of-reflection" target="_blank" rel="noopener">The Go Blog</a> : 其实看官方说明就足以了！</li><li><a href="https://golang.org/pkg/reflect/#Kind" target="_blank" rel="noopener">官方reflect-Kind</a></li><li><a href="http://www.jb51.net/article/90021.htm" target="_blank" rel="noopener">Go语言的反射三定律</a></li><li><a href="https://studygolang.com/articles/11287" target="_blank" rel="noopener">Go基础学习五之接口interface、反射reflection</a></li><li><a href="https://studygolang.com/articles/12349" target="_blank" rel="noopener">提高 golang 的反射性能</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ips</title>
      <link href="/2020/03/13/ips/"/>
      <url>/2020/03/13/ips/</url>
      
        <content type="html"><![CDATA[<h1 id="使用golang获取本机ip"><a href="#使用golang获取本机ip" class="headerlink" title="使用golang获取本机ip"></a>使用golang获取本机ip</h1><h2 id="话不多说，直接上代码"><a href="#话不多说，直接上代码" class="headerlink" title="话不多说，直接上代码"></a>话不多说，直接上代码</h2><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token comment" spellcheck="true">// 获取本机全部网卡的全部IP</span><span class="token comment" spellcheck="true">// 2020-03-12 16:52</span><span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"fyne.io/fyne/app"</span>    <span class="token string">"fyne.io/fyne/widget"</span>    <span class="token string">"net"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取全部网卡的全部IP</span><span class="token keyword">func</span> <span class="token function">Ips</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ips <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//返回 interface 结构体对象的列表，包含了全部网卡信息</span>    interfaces<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Interfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//遍历全部网卡</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> interfaces <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Addrs() 方法返回一个网卡上全部的IP列表</span>        address<span class="token punctuation">,</span> err <span class="token operator">:=</span> i<span class="token punctuation">.</span><span class="token function">Addrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//遍历一个网卡上全部的IP列表，组合为一个字符串，放入对应网卡名称的map中</span>        <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> address <span class="token punctuation">{</span>            ips<span class="token punctuation">[</span>i<span class="token punctuation">.</span>Name<span class="token punctuation">]</span> <span class="token operator">+=</span> v<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ips<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> ips <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span>    ips<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">Ips</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> ipstring <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">//key是网卡名称，value是网卡IP</span>    <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> ips <span class="token punctuation">{</span>        ipstring <span class="token operator">+=</span> <span class="token string">"adapter name: "</span> <span class="token operator">+</span> k <span class="token operator">+</span> <span class="token string">"  IP: "</span> <span class="token operator">+</span> v <span class="token operator">+</span> <span class="token string">"\n"</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//使用 fyne 画到 GUI 界面上</span>    myApp <span class="token operator">:=</span> app<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    myWindow <span class="token operator">:=</span> myApp<span class="token punctuation">.</span><span class="token function">NewWindow</span><span class="token punctuation">(</span><span class="token string">"Network Info"</span><span class="token punctuation">)</span>    myWindow<span class="token punctuation">.</span><span class="token function">SetContent</span><span class="token punctuation">(</span>widget<span class="token punctuation">.</span><span class="token function">NewLabel</span><span class="token punctuation">(</span>ipstring<span class="token punctuation">)</span><span class="token punctuation">)</span>    myWindow<span class="token punctuation">.</span><span class="token function">Show</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    myApp<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">tidyUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">tidyUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Exited"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行效果如图</p><img src="/2020/03/13/ips/ip.jpg" class="" title="This is an example image"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
